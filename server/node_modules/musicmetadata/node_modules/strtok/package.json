{
  "name": "strtok",
  "version": "0.1.1",
  "description": "A streaming tokenizer",
  "author": {
    "name": "Peter Griess",
    "email": "pg@std.in"
  },
  "engines": {
    "node": ">=0.1.98"
  },
  "repositories": [
    {
      "type": "git",
      "url": "http://github.com/pgriess/node-strtok"
    }
  ],
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/pgriess/node-strtok/blob/master/LICENSE"
    }
  ],
  "main": "./lib/strtok.js",
  "readme": "A streaming tokenizer for [NodeJS](http://nodejs.org).\n\nParsing data coming off the wire in an event-driven environment can be a\ndifficult proposition, with naive implementations buffering all received data\nin memory until a message has been received in its entirety. Not only is this\ninfficient from a memory standpoint, but it may not be possible to determine\nthe that a message has been fully received without attempting to parse it.\nThis requires a parser that can gracefully handle incomplete messages and\npick up where it left off. To make this task easier, `node-strtok` provides\n\n* Tokenizing primitives for common network datatypes (e.g. signed and\n  unsigned integers in variois endian-nesses).\n* A callback-driven approach well suited to an asynchronous environment (e.g.\n  to allow the application to asynchronously ask another party for\n  information about what the next type should be)\n* An easily extensible type system for adding support for new,\n  application-defined types to the core.\n* Very good performance; the built-in MsgPack parser performs within 30% of\n  the native C++ implementation.\n\n## Usage\n\nThe `node-strtok` library has only one method: `parse()`.  This method takes a\n`net.Stream` (really any `EventEmitter` that pumps out `data` events) and a\ncallback, which is invoked when a complete token has been read from the stream.\nThe callback takes a single argument: the token just read from the stream, and\nis expected to return the type of token to read from the stream next (e.g.\n`strtok.UINT32_BE`). It is this callback that ultimately implements the\napplication protocol, consuming the provided tokens and instructing\n`node-strtok` the type of the next token to read. It is this inverted control\nflow that allows `node-strtok` to function efficiently as an interruptable\nparser well suited to NodeJS.\n\nThe meat of implementing an application protocol is to be found in what it does\nin its callback function.\n\nWhen `parse()` is invoked, it immediately invokes the callback with a value of\n`undefined`. In this way, the application can indicate the type of token to\nread from the stream first. For example, the MsgPack implementation always\nreads a `strtok.UINT8` when it doesn't know what's coming next; it interprets\nthe resulting value as a type (e.g. integer, array, etc) to determine what type\nof value is coming next.\n\nImplicit in this model is that the callback itself must maintain all\nprotocol-specific state on its own. Often this will include what type of\nstructure it's attmpting to parse from the stream, and the progress made so far\nin parsing that structure.\n\n### Tokens\n\n`node-strtok` supports a wide variety of numerical tokens out of the box:\n\n* `UINT8`\n* `UINT16_BE`, `UINT16_LE`\n* `UINT32_BE`,  `UINT32_LE`\n* `INT8`\n* `INT16_BE`\n* `INT32_BE`\n\nOne might notice that there is no support for 64-bit tokens, since JavaScript\nseems to limit value size to less than 2^64. Rather than wrapping up an\nadditional math library to handle this, I wanted to stick with JavaScript\nprimitives. Maybe this will change later if this becomes important.\n\n#### Special tokens\n\nThere are a handful of \"special\" tokens which have special meaning when\nreturned from the protocol callback: `DONE` and `DEFER`. \n\nThe `DONE` token indicates to `strtok.parse()` that the protocol parsing loop\nhas come to an end, and that no more data need be read off of the stream. This\ncauses `strtok.parse()` to disengage from the stream. The callback will not be\ninvoked again. In addition, upon receiving `DONE`, `strtok.parse()` may have\nexcess data buffers which it has pulled off of the stream, but which it did not\nconsume while being directed by the protocol callback. Rather than dropping\nthis data on the floor, `strtok.parse()` will synthesize and emit `data` events\non the stream which it was operating on. The idea is to facilitate protocol\nstacks which want to use `node-strtok` to parse some portion of the protocol\nand then hand off processing to some other codepath(s). In this case, it is\nexpected that the protocol callback will add `data` event listeners to the\nstream immediately before returning `DONE`.\n\nThe `DEFER` token indicates that the protocol doesn't know what type of token\nto read from the stream next. Perhaps the protocol needs to consult some\nout-of-process datastructure, or wait for some other event to occur. To support\nthis case, the protocol callback is actually invoked with 2 arguments: the\nvalue and a defer callback. It is this second parameter, a callback, that must\nbe invoked with the desired token type once the protocol layer has figured this\nout. Note that between the time `DEFER` is returned and the callback is\ninvoked, `strtok.parse()` is buffering all data received from the stream.\n\n#### Complex tokens\n\nThe token types returned from the protocol callback are simply objects with\n1) a `get()` method that takes a `Buffer` and an offset and returns the token\nvalue, and 2) a `len` field that indicates the number of bytes to consume.\nAny JavaScript object that meets this criteria can be returned from the\nprotocol callback. `node-strtok` ships with two built-in types for supporting\ncommon behavior that take advantage of this\n\n* `BufferType` -- consume a fixed number of bytes from the stream and\n  return a `Buffer` instance containing these bytes.\n* `StringType` -- consume a fixed number of bytes from the stream and\n  return a string with a specified encoding.\n\nImplementing such types is extremely simple. The `BufferType` implementation\nis given below:\n\n    var BufferType = function(l) {\n        var self = this;\n\n        self.len = l;\n\n        self.get = function(buf, off) {\n            return buf.slice(off, off + this.len);\n        };\n    };\n    exports.BufferType = BufferType;\n\n### A simple example\n\nBelow is an example of a parser for a simple protocol. Each message is a\nUTF-8 string, prefixed with a big-endian unsigned 32-bit integer used as a\nlength specifier.\n\n    var strotk = require('strtok');\n\n    var s = ... /* a net.Stream workalike */;\n    \n    var numBytes = -1;\n    \n    strtok.parse(s, function(v, cb) {\n        if (v === undefined) {\n            return strtok.UINT32_BE;\n        }\n    \n        if (numBytes == -1) {\n            numBytes = v;\n            return new strtok.StringType(v, 'utf-8');\n        }\n\n        console.log('Read ' + v);\n        numBytes = -1;\n        return strtok.UINT32_BE;\n    });\n\nWhen the callback is first invoked, we aren't in the midst of reading a\nmessage, so we ask for a `UINT32_BE` to get the length of the subsequent\nstring. At this point, on every invocation of our callback, we use our\ninternal `numBytes` variable to determine if we're reading a number-of-bytes\nvalue or a string value. In the former case, we're called with the\nnumber-of-bytes value and return a `StringType` instance that knows to read\nthe specified number of bytes from the stream. In the latter case, we get the\nstring itself, log it, and then ask for a length again. Lather, rinse,\nrepeat.\n\n### A more complex example\n\nThe\n[examples/msgpack/msgpack.js](http://github.com/pgriess/node-strtok/blob/master/examples/msgpack/msgpack.js)\nfile contains an implementation of the [MsgPack serialization\nspec](http://redmine.msgpack.org/projects/msgpack/wiki/FormatSpec).\n\n## Performance\n\nAn example run of the built-in `examples/msgpack/bench.js`:\n\n    json\n      pack:   14674 ms (100% of json)\n      unpack: 50479 ms (100% of json)\n\n    native\n      pack:   15334 ms (104% of json)\n      unpack: 32835 ms (65% of json)\n\n    strtok\n      pack:   15861 ms (108% of json)\n      unpack: 46650 ms (92% of json)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "http://github.com/pgriess/node-strtok"
  },
  "bugs": {
    "url": "https://github.com/pgriess/node-strtok/issues"
  },
  "_id": "strtok@0.1.1",
  "_from": "strtok@0.1.1"
}
